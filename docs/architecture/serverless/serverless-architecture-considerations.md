---
title: 서버를 사용 하지 않는 아키텍처 고려 사항-서버 리스 앱
description: 상태 관리 및 영구 저장소에서 크기 조정, 로깅, 추적 및 진단으로 서버 리스 응용 프로그램을 설계 하는 문제를 이해 합니다.
author: JEREMYLIKNESS
ms.author: jeliknes
ms.date: 06/26/2018
ms.openlocfilehash: ecbffbbd435b4926608e4def519fdaddddab688d
ms.sourcegitcommit: f20dd18dbcf2275513281f5d9ad7ece6a62644b4
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 07/30/2019
ms.locfileid: "69577436"
---
# <a name="serverless-architecture-considerations"></a>서버리스 아키텍처 고려 사항

서버를 사용 하지 않는 아키텍처를 채택 하면 특정 과제가 발생 합니다. 이 섹션에서는 알아야 할 몇 가지 일반적인 고려 사항을 살펴봅니다. 이러한 모든 문제에는 솔루션이 있습니다. 모든 아키텍처를 선택 하는 것과 마찬가지로 서버를 사용 하지 않는 것은 장점 및 단점을 신중 하 게 고려한 후에만 수행 하도록 결정 해야 합니다. 응용 프로그램의 요구에 따라 서버 리스 구현이 특정 구성 요소에 적합 한 솔루션이 아님을 결정할 수 있습니다.

## <a name="managing-state"></a>상태 관리

일반적으로 마이크로 서비스와 마찬가지로 서버를 사용 하지 않는 함수는 기본적으로 상태 비저장입니다. 상태를 방지 하면 서버 리스를 사용 하지 않도록 설정 하 고, 규모를 확장 하 고, 중앙의 실패 지점 없이 복원 력을 제공할 수 있습니다. 경우에 따라 비즈니스 프로세스에는 상태가 필요 합니다. 프로세스에 상태가 필요한 경우 두 가지 옵션이 있습니다. 서버를 사용 하지 않는 모델을 채택 하거나 상태를 제공 하는 별도의 서비스와 상호 작용할 수 있습니다. 상태를 추가 하면 솔루션이 복잡 해질 수 있으며 확장 하기가 더 어렵고 잠재적으로 단일 실패 지점이 생성 될 수 있습니다. 함수가 반드시 상태를 요구 하는지 신중 하 게 고려해 야 합니다. 대답이 "예" 인 경우 서버를 사용 하지 않는 상태로 구현 하는 것이 적절 한지 여부를 확인 합니다.

서버 리스의 이점을 손상 시 키 지 않고 상태를 채택 하는 여러 솔루션이 있습니다. 가장 인기 있는 솔루션 중 일부는 다음과 같습니다.

* Redis와 같은 임시 데이터 저장소 또는 분산 캐시를 사용 합니다.
* SQL 또는 CosmosDB와 같은 데이터베이스에 상태를 저장 합니다.
* 지속형 함수와 같은 워크플로 엔진을 통해 상태를 처리 합니다.

아래 줄은 서버를 사용 하지 않는 상태로 구현 하려는 프로세스 내에서 상태 관리의 필요성에 대해 알고 있어야 합니다.

## <a name="long-running-processes"></a>장기 실행 프로세스

서버를 사용 하지 않는 여러 가지 이점은 삭제 중인 프로세스를 사용 합니다. 짧은 실행 시간을 사용 하면 서버를 사용 하지 않는 공급자가 함수 종료와 호스트 간에 함수를 공유 하는 리소스를 더 쉽게 사용할 수 있습니다. 대부분의 클라우드 공급자는 함수를 실행할 수 있는 총 시간을 10 분 정도 제한 합니다. 프로세스에 더 많은 시간이 걸릴 수 있는 경우 대체 구현을 고려할 수 있습니다.

몇 가지 예외와 솔루션이 있습니다. 한 가지 해결 방법은 프로세스를 개별적으로 실행 하는 데 걸리는 시간을 단축 하는 작은 구성 요소로 나누는 것입니다. 종속성으로 인해 프로세스가 장시간 실행 되는 경우 지속형 함수와 같은 솔루션을 사용 하 여 비동기 워크플로를 고려할 수도 있습니다. 지 속성 함수는 외부 프로세스가 완료 될 때까지 대기 하는 동안 프로세스의 상태를 일시 중지 하 고 유지 합니다. 비동기 처리를 통해 실제 프로세스가 실행 되는 시간이 줄어듭니다.

## <a name="startup-time"></a>시작 시간

서버를 사용 하지 않는 구현의 한 가지 잠재적인 문제는 시작 시간입니다. 리소스를 절약 하기 위해 서버를 사용 하지 않는 많은 공급자는 "주문형" 인프라를 만듭니다. 서버를 사용 하지 않는 함수를 일정 시간 후에 트리거되면 함수를 호스트 하는 리소스를 만들거나 다시 시작 해야 할 수 있습니다. 콜드 시작으로 인해 몇 초 정도 지연 될 수 있는 경우도 있습니다. 시작 시간은 공급자와 서비스 수준에 따라 달라 집니다. 응용 프로그램의 성공 여부를 최소화 하는 것이 중요 한 경우 시작 시간을 해결 하는 몇 가지 방법이 있습니다.

* 일부 공급자는 사용자가 인프라를 "항상 사용" 하도록 보장 하는 서비스 수준에 대해 지불할 수 있습니다.
* 연결 유지 메커니즘을 구현 합니다 (끝점을 ping 하 여 "활성" 상태로 유지).
* 컨테이너 화 된 함수를 사용 하 여 Kubernetes와 같은 오케스트레이션을 사용 합니다. 호스트는 이미 실행 되 고 있으므로 새 인스턴스를 빠르게 회전 합니다.

## <a name="database-updates-and-migrations"></a>데이터베이스 업데이트 및 마이그레이션

서버를 사용 하지 않는 코드의 이점은 전체 응용 프로그램을 다시 배포 하지 않고도 새 함수를 해제할 수 있다는 점입니다. 이러한 이점은 관련 된 관계형 데이터베이스가 있는 경우에 단점이 될 수 있습니다. 데이터베이스 스키마에 대 한 변경 내용은 서버를 사용 하지 않는 업데이트와 동기화 하기 어렵습니다. 문제가 발생 하 여 변경 내용을 롤백해야 하는 경우 추가 과제가 발생 합니다. 데이터 무결성은 마이크로 서비스 및 서버를 사용 하지 않는 함수에 대 한 모범 사례는 자신의 데이터를 소유 하는 한 가지 이유입니다. 변경 내용을 계산 및 데이터의 단일 단위로 배포할 수 있습니다. 현실에서는 많은 레거시 시스템에서 서버를 사용 하지 않는 아키텍처와 조정 해야 하는 대량 백 엔드 데이터베이스를 사용할 수 있습니다.

스키마 버전 관리를 해결 하는 일반적인 방법은 기존 속성 및 열을 수정 하지 않고 새 정보를 추가 하는 것입니다. 예를 들어 작업 목록에 대 한 부울 "완료 됨" 플래그에서 "완료 된 날짜"로 이동 하기 위해 변경 내용을 고려 합니다. 이전 필드를 제거 하는 대신 데이터베이스 변경 작업은 다음과 같습니다.

1. 새 "완료 된 날짜" 필드를 추가 합니다.
1. "Completed" 부울 필드를 완료 된 날짜가 현재 날짜 이후 인지 여부를 평가 하는 계산 함수로 변환 합니다.
1. 완료 된 부울이 true로 설정 된 경우 완료 된 날짜를 현재 날짜로 설정 하는 트리거를 추가 합니다.

새 서버를 사용 하지 않는 함수는 새 필드를 활용할 수 있지만 변경 시퀀스를 통해 레거시 코드는 "있는 그대로" 계속 실행 됩니다.

서버를 사용 하지 않는 아키텍처의 데이터에 대 한 자세한 내용은 [분산 데이터 관리를 위한 과제 및 해결 방법](../microservices/architect-microservice-container-applications/distributed-data-management.md)을 참조 하세요.

## <a name="scaling"></a>크기 조정

서버를 사용 하지 않는 일반적인 오해 "서버 없음"을 의미 합니다. 실제로 "서버 없음"입니다. 크기를 조정 해야 하는 경우를 이해 하는 것이 중요 합니다. 서버를 사용 하지 않는 대부분의 플랫폼에서는 이벤트 밀도가 증가할 때 인프라의 크기를 조정 하는 방법을 처리 하는 컨트롤 집합을 제공 합니다. 다양 한 옵션 중에서 선택할 수 있지만 전략은 함수에 따라 달라질 수 있습니다. 또한 함수는 일반적으로 관련 호스트에서 실행 되므로 동일한 호스트의 함수는 동일한 크기 조정 옵션을 사용할 수 있습니다. 따라서 크기 조정 요구 사항에 따라 함께 호스트 되는 함수를 구성 하 고 세우고 해야 합니다.

규칙은 다양 한 매개 변수에 따라 확장 (호스트 리소스 증가) 및 확장 (호스트 인스턴스 수 증가)을 지정 하는 방법을 지정 하는 경우가 많습니다. 크기 조정에 대 한 트리거는 일정, 요청 속도, CPU 사용률 및 메모리 사용을 포함할 수 있습니다. 성능이 높을수록 비용이 더 많이 듭니다. 저렴 하 고 소비 기반 접근 방식은 요청 속도가 갑자기 증가 하는 경우 신속 하 게 확장 되지 않을 수 있습니다. "보험 비용"을 지불 하는 것과 ' 지불 비용 '을 엄격히 절충 하는 것과 갑작스러운 수요 급증으로 인해 응답 속도가 느려질 수 있습니다.

## <a name="monitoring-tracing-and-logging"></a>모니터링, 추적 및 로깅

DevOps의 종종 간과 되는 측면은 배포 된 응용 프로그램을 모니터링 하는 것입니다. 서버를 사용 하지 않는 함수를 모니터링 하기 위한 전략을 수립 하는 것이 중요 합니다. 가장 큰 문제는 종종 상관 관계 이거나 사용자가 동일한 상호 작용의 일부로 여러 함수를 호출 하는 경우를 인식 하는 것입니다. 서버를 사용 하지 않는 대부분의 플랫폼에서는 타사 도구로 가져올 수 있는 콘솔 로깅을 허용 합니다. 원격 분석 컬렉션을 자동화 하 고 상관 관계 Id를 생성 및 추적 하 고 특정 작업을 모니터링 하 여 자세한 정보를 제공 하는 옵션도 있습니다. Azure는 모니터링 및 분석을 위한 고급 [Application Insights 플랫폼](https://docs.microsoft.com/azure/azure-functions/functions-monitoring) 을 제공 합니다.

## <a name="inter-service-dependencies"></a>서비스 간 종속성

서버를 사용 하지 않는 아키텍처에는 다른 함수를 사용 하는 함수가 포함 될 수 있습니다. 실제로 여러 서비스가 상호 작용 또는 분산 트랜잭션의 일부로 서로 호출 하는 서버를 사용 하지 않는 아키텍처에서는 일반적이 지 않습니다. 강력한 결합을 방지 하려면 서비스에서 서로를 직접 참조 하지 않는 것이 좋습니다. 서비스의 끝점을 변경 해야 하는 경우 직접 참조로 인해 주요 리팩터링이 발생할 수 있습니다. 권장 되는 해결 방법은 요청 유형에 적합 한 끝점을 제공 하는 서비스 검색 메커니즘 (예: 레지스트리)을 제공 하는 것입니다. 또 다른 해결 방법은 서비스 간 통신에 큐 또는 항목과 같은 메시징 서비스를 활용 하는 것입니다.

## <a name="managing-failure-and-providing-resiliency"></a>오류 관리 및 복원 력 제공

*회로 차단기 패턴*을 고려 하는 것도 중요 합니다. 어떤 이유로 인해 서비스가 계속 실패 하면 해당 서비스를 반복 해 서 호출 하지 않는 것이 좋습니다. 대신, 대체 서비스를 호출 하거나 종속 서비스의 상태가 다시 설정 될 때까지 메시지를 반환 합니다. 서버를 사용 하지 않는 아키텍처는 서비스 간 종속성을 확인 하 고 관리 하기 위한 전략을 고려해 야 합니다.

회로 차단기 패턴을 계속 하려면 서비스에 내결함성 및 복원 력이 있어야 합니다. 내결함성은 예기치 않은 예외 또는 잘못 된 상태 발생 후에도 응용 프로그램을 계속 실행 하는 기능을 의미 합니다. 내결함성은 일반적으로 코드 자체의 기능이 며 예외를 처리 하기 위해 작성 되는 방법입니다. 복원 력은 응용 프로그램에서 오류를 복구할 수 있는 방법을 나타냅니다. 복원 력은 종종 서버를 사용 하지 않는 플랫폼에서 관리 됩니다. 플랫폼은 기존 서버를 사용 하지 않을 때 새 서버를 사용 하지 않는 함수 인스턴스를 실행할 수 있어야 합니다. 또한 플랫폼은 모든 새 인스턴스가 실패할 때 새 인스턴스를 중지 하기에 충분히 지능적 이어야 합니다.

자세한 내용은 [회로 차단기 패턴 구현](../microservices/implement-resilient-applications/implement-circuit-breaker-pattern.md)을 참조 하세요.

## <a name="versioning-and-greenblue-deployments"></a>버전 관리 및 녹색/파랑 배포

서버를 사용 하지 않는 주요 혜택은 전체 응용 프로그램을 다시 배포할 필요 없이 특정 기능을 업그레이드 하는 기능입니다. 업그레이드에 성공 하려면 함수를 호출 하는 서비스가 올바른 버전의 코드로 라우팅되도록 함수를 버전 관리 해야 합니다. 새 버전을 배포 하는 전략도 중요 합니다. 일반적인 방법은 "녹색/파랑 배포"를 사용 하는 것입니다. 녹색 배포는 현재 함수입니다. 새 "blue" 버전이 프로덕션에 배포 되 고 테스트 됩니다. 테스트를 통과 하면 녹색 및 파란색 버전이 교체 되어 새 버전이 라이브 상태가 됩니다. 문제가 발생 하는 경우 다시 바꿀 수 있습니다. 버전 관리 및 녹색/파랑 배포를 지원 하려면 버전 변경을 수용 하 고 서버를 사용 하지 않는 플랫폼을 사용 하 여 배포를 처리 하는 함수를 작성 해야 합니다. 가능한 한 가지 방법은 [Azure 서버](azure-functions.md#proxies) 를 사용 하지 않는 플랫폼 챕터에 설명 된 프록시를 사용 하는 것입니다.

>[!div class="step-by-step"]
>[이전](serverless-architecture.md)
>[다음](serverless-design-examples.md)
