---
title: 컴파일러 지시문
description: 언어 전처리기 F# 지시문, 조건부 컴파일 지시문, 줄 지시문 및 컴파일러 지시문에 대해 알아봅니다.
ms.date: 12/10/2018
ms.openlocfilehash: 16db2efb2fee2c2c5e94aa98eb0a13183a4e0e0b
ms.sourcegitcommit: f20dd18dbcf2275513281f5d9ad7ece6a62644b4
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 07/30/2019
ms.locfileid: "68630407"
---
# <a name="compiler-directives"></a>컴파일러 지시문

이 항목에서는 처리기 지시문과 컴파일러 지시문에 대해 설명합니다.

## <a name="preprocessor-directives"></a>전처리기 지시문

전처리기 지시문은 # 기호를 접두사로 사용하며 따로 한 줄을 할애하여 지시문을 작성합니다. 이 지시문은 컴파일러 자체보다 먼저 실행되는 전처리기를 통해 해석됩니다.

다음 표에는 F#에서 사용할 수 있는 전처리기 지시문의 목록이 나와 있습니다.

|지시문|Description|
|---------|-----------|
|`#if` *symbol*|조건부 컴파일을 지원합니다. `#if` *기호가* 정의 된 경우이 포함 된 후의 섹션에 있는 코드입니다. 기호는로 `!`부정할 수도 있습니다.|
|`#else`|조건부 컴파일을 지원합니다. 위의 `#if`와 함께 사용되는 기호를 정의하지 않은 경우 포함할 코드 섹션을 표시합니다.|
|`#endif`|조건부 컴파일을 지원합니다. 코드의 조건부 섹션이 끝나는 지점을 표시합니다.|
|`#`[line] *int*,<br/>`#`[line] *int* *string*,<br/>`#`[line] *int* *verbatim-string*|디버깅을 위해 원본 소스 코드 줄과 파일 이름을 표시합니다. 이 기능은 F# 소스 코드를 생성하는 도구에서 사용할 수 있습니다.|
|`#nowarn` *warningcode*|컴파일러 경고를 해제합니다. 경고를 해제하려면 컴파일러 출력에서 해당 번호를 찾아 따옴표에 포함합니다. "FS" 접두사를 생략합니다. 같은 줄에서 여러 경고 번호를 해제하려면 각 번호를 따옴표에 포함하고 각 문자열을 공백으로 구분합니다. 예를 들어:

`#nowarn "9" "40"`

경고를 사용 하지 않도록 설정 하는 영향은 지시문 앞에 있는 파일의 일부를 포함 하 여 전체 파일에 적용 됩니다. |

## <a name="conditional-compilation-directives"></a>조건부 컴파일 지시문

이러한 지시문 중 하나로 비활성화 된 코드는 Visual Studio Code 편집기에서 흐리게 표시 됩니다.

> [!NOTE]
> 다른 언어에 있는 그대로 동일한 조건부 컴파일 지시문의 동작을 볼 수 없습니다. 예를 들어 기호가 포함된 부울 식은 사용할 수 없으며 `true` 및 `false`가 특별한 의미를 가지지도 않습니다. `if` 지시문에 사용하는 기호는 명령줄이나 프로젝트 설정에서 정의해야 합니다. `define` 전처리기 지시문이 없습니다.

다음 코드에서는 `#if`, `#else` 및 `#endif` 지시문을 사용하는 방법을 보여 줍니다. 이 예제의 코드에는 `function1`에 대한 두 가지 버전의 정의가 포함되어 있습니다. [-Define 컴파일러 옵션](https://msdn.microsoft.com/library/434394ae-0d4a-459c-a684-bffede519a04)을 사용 하 여가 정의 되 면 `#if` `VERSION1` 지시문과 `#else` 지시문 사이에 있는 코드가 활성화 됩니다. 그렇지 않은 경우에는 `#else`와 `#endif` 사이의 코드가 활성화됩니다.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-2/snippet7301.fs)]

F#에는 `#define` 전처리기 지시문이 없습니다. `#if` 지시문에 사용되는 기호를 정의하려면 컴파일러 옵션이나 프로젝트 설정을 사용해야 합니다.

조건부 컴파일 지시문은 중첩하여 사용할 수 있습니다. 전처리기 지시문에서 들여쓰기는 중요하지 않습니다.

를 사용 하 여 `!`기호를 부정할 수도 있습니다. 이 예제에서 문자열의 값은 디버깅 _하지 않을_ 경우에만 해당 됩니다.

```fsharp
#if !DEBUG
let str = "Not debugging!"
#else
let str = "Debugging!"
#endif
```

## <a name="line-directives"></a>줄 지시문

빌드 과정에서 컴파일러를 통해 F# 코드의 오류를 보고할 때는 각 오류의 발생 지점에 해당하는 줄 번호가 참조 정보로 사용됩니다. 이러한 줄 번호는 1부터 시작합니다. 파일의 맨 첫 줄이 1번입니다. 그러나 다른 도구를 사용하여 F# 소스 코드를 생성하는 경우에는 생성된 코드의 줄 번호가 일반적으로 크게 중요하지 않습니다. 생성된 F# 코드의 오류가 다른 소스에서 발생한 것일 가능성이 높기 때문입니다. `#line` 지시문을 사용하면 다른 도구를 통해 F# 소스 코드를 생성할 때 원래 줄 번호와 소스 파일에 대한 정보를 생성된 F# 코드에 전달할 수 있습니다.

`#line` 지시문을 사용하는 경우 파일 이름을 따옴표로 묶어야 합니다. 문자열 앞에 축자 토큰(`@`)이 오지 않는 경우 백슬래시 문자를 경로에 사용하려면 한 개가 아닌 두 개의 백슬래시 문자를 사용하여 이를 이스케이프해야 합니다. 다음은 유효한 줄 토큰입니다. 이 예제에서는 도구를 사용하여 원래 파일 `Script1`을 실행한 결과로 F# 코드 파일이 자동 생성되며 이러한 지시문이 있는 위치의 코드가 파일 `Script1`의 25번 줄에 있는 몇몇 토큰으로부터 생성되는 것으로 가정합니다.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-2/snippet7303.fs)]

이 토큰은 해당 위치에서 생성되는 F# 코드가 `Script1`의 `25`번 줄 또는 그 부근에 있는 몇몇 구문으로부터 파생됨을 나타냅니다.

## <a name="compiler-directives"></a>컴파일러 지시문

컴파일러 지시문은 # 기호가 접두사로 사용된다는 점에서 전처리기 지시문과 형태가 비슷하지만 전처리기에 의해 해석되지 않고 컴파일러를 통해 해석 및 처리되도록 남겨진다는 점에서 차이가 있습니다.

다음 표에는 F#에서 사용할 수 있는 컴파일러 지시문이 나와 있습니다.

|지시문|설명|
|---------|-----------|
|`#light` ["on"&#124;"off"]|다른 ML 버전과의 호환성을 위해 간단한 구문을 사용하거나 사용하지 않도록 설정합니다. 기본적으로 간단한 구문을 사용하도록 설정됩니다. 자세한 구문은 항상 사용할 수 있도록 설정됩니다. 따라서 간단한 구문과 자세한 구문을 함께 사용할 수 있습니다. `#light` 지시문 자체는 `#light "on"`과 같습니다. `#light "off"`를 지정하는 경우에는 모든 언어 구문에 대해 자세한 구문 형식을 사용해야 합니다. F# 관련 설명에 나오는 구문은 간단한 구문을 사용하는 것을 전제로 하여 제시됩니다. 자세한 내용은 자세한 [구문](verbose-syntax.md)을 참조 하세요.|

인터프리터 (fsi.exe) 지시문은를 [ F#사용한 대화형 프로그래밍 ](../tutorials/fsharp-interactive/index.md)을 참조 하세요.

## <a name="see-also"></a>참고자료

- [F# 언어 참조](index.md)
- [컴파일러 옵션](compiler-options.md)
