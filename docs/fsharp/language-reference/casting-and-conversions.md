---
title: 캐스팅 및 변환
description: 프로그래밍 언어에서 F# 다양 한 기본 형식 간의 산술 변환에 대 한 변환 연산자를 제공 하는 방법에 대해 알아봅니다.
ms.date: 05/16/2016
ms.openlocfilehash: ee4df588caabf58c7b9e18961e217ef8f15fcf93
ms.sourcegitcommit: f20dd18dbcf2275513281f5d9ad7ece6a62644b4
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 07/30/2019
ms.locfileid: "68630428"
---
# <a name="casting-and-conversions-f"></a>캐스팅 및 변환(F#)

이 항목에서는의 F#형식 변환에 대 한 지원에 대해 설명 합니다.

## <a name="arithmetic-types"></a>산술 형식

F#정수 및 부동 소수점 형식 등 다양 한 기본 형식 간의 산술 변환을 위한 변환 연산자를 제공 합니다. 정수 및 문자 변환 연산자에는 checked 및 unchecked 형식이 있습니다. 부동 소수점 연산자와 `enum` 변환 연산자는 그렇지 않습니다. 선택 하지 않은 폼은에 `Microsoft.FSharp.Core.Operators` 정의 되 고 선택 된 폼은 `Microsoft.FSharp.Core.Operators.Checked`에 정의 됩니다. 결과 값이 대상 형식의 제한을 초과 하는 경우 확인 된 폼에서 오버플로를 확인 하 고 런타임 예외를 생성 합니다.

이러한 각 연산자는 대상 형식의 이름과 동일한 이름을 갖습니다. 예를 들어 형식에 명시적으로 주석을 추가 `byte` 하는 다음 코드에서는 두 가지 의미를 사용 하 여 표시 됩니다. 첫 번째 항목은 형식이 고 두 번째 항목은 변환 연산자입니다.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-2/snippet4401.fs)]

다음 표에서는에 F#정의 된 변환 연산자를 보여 줍니다.

|연산자|Description|
|--------|-----------|
|`byte`|부호 없는 8 비트 형식인 바이트로 변환 합니다.|
|`sbyte`|부호 있는 바이트로 변환 합니다.|
|`int16`|부호 있는 16 비트 정수로 변환 합니다.|
|`uint16`|부호 없는 16 비트 정수로 변환 합니다.|
|`int32, int`|32 비트 부호 있는 정수로 변환 합니다.|
|`uint32`|32 비트 부호 없는 정수로 변환 합니다.|
|`int64`|64 비트 부호 있는 정수로 변환 합니다.|
|`uint64`|64 비트 부호 없는 정수로 변환 합니다.|
|`nativeint`|네이티브 정수로 변환 합니다.|
|`unativeint`|부호 없는 네이티브 정수로 변환 합니다.|
|`float, double`|64 비트 배정밀도 IEEE 부동 소수점 숫자로 변환 합니다.|
|`float32, single`|32 비트 단 정밀도 IEEE 부동 소수점 숫자로 변환 합니다.|
|`decimal`|을로 `System.Decimal`변환 합니다.|
|`char`|`System.Char`을 유니코드 문자로 변환 합니다.|
|`enum`|열거형 형식으로 변환 합니다.|

기본 제공 기본 형식 외에도 이러한 연산자를 적절 한 서명이 있는 또는 `op_Explicit` `op_Implicit` 메서드를 구현 하는 형식과 함께 사용할 수 있습니다. 예를 들어 변환 `int` 연산자는 형식을 매개 변수로 사용 하 고를 반환 `int`하 `op_Explicit` 는 정적 메서드를 제공 하는 모든 형식에서 작동 합니다. 반환 형식으로 메서드를 오버 로드할 수 없다는 일반적인 규칙에 대 한 특별 한 예외로, 및 `op_Explicit` `op_Implicit`에 대해이 작업을 수행할 수 있습니다.

## <a name="enumerated-types"></a>열거 형식

연산자는 변환할 `enum` 의 형식을 나타내는 하나의 형식 매개 변수를 사용 하는 제네릭 연산자입니다. `enum` 열거형 형식으로 변환 하는 경우 형식 유추는 변환 하려는의 형식을 `enum` 결정 하려고 합니다. 다음 예제에서 변수 `col1` 는 명시적으로 주석이 추가 되지 않지만 해당 형식은 이후 같음 테스트에서 유추 됩니다. 따라서 컴파일러가 `Color` 열거형으로 변환 하는 것으로 추론할 수 있습니다. 또는 다음 예제와 `col2` 같이 형식 주석을 제공할 수 있습니다.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-2/snippet4402.fs)]

다음 코드와 같이 명시적으로 대상 열거 형식을 형식 매개 변수로 지정할 수도 있습니다.

```fsharp
let col3 = enum<Color> 3
```

열거형은 열거형의 내부 형식이 변환 중인 형식과 호환 되는 경우에만 작동 합니다. 다음 코드에서는 `int32` 와 `uint32`가 일치 하지 않기 때문에 변환이 컴파일되지 않습니다.

```fsharp
// Error: types are incompatible
let col4 : Color = enum 2u
```

자세한 내용은 [열거형](enumerations.md)을 참조 하세요.

## <a name="casting-object-types"></a>개체 형식 캐스팅

개체 계층 구조에서 형식 간의 변환은 개체 지향 프로그래밍의 기본입니다. 변환에는 두 가지 기본 형식 (업캐스팅)과 캐스팅 (좋기는)이 있습니다. 계층을 위로 캐스팅 하는 것은 파생 된 개체 참조에서 기본 개체 참조로 캐스팅 하는 것을 의미 합니다. 이러한 캐스트는 기본 클래스가 파생 클래스의 상속 계층 구조에 있는 한 작동 하도록 보장 됩니다. 계층에서 파생 된 개체 참조에 대 한 기본 개체 참조로 캐스팅 하는 것은 개체가 실제로 올바른 대상 (파생 된 대상) 형식의 인스턴스이거나 대상 형식에서 파생 된 형식인 경우에만 성공 합니다.

F#이러한 변환 형식에 대 한 연산자를 제공 합니다. 연산자 `:>` 는 계층을 위로 캐스팅 하 고 연산자 `:?>` 는 계층 구조를 아래로 캐스팅 합니다.

### <a name="upcasting"></a>업캐스팅

많은 개체 지향 언어에서 업캐스팅는 암시적입니다. 에서 F#규칙은 약간 다릅니다. 업캐스팅는 개체 형식에 대 한 메서드에 인수를 전달 하면 자동으로 적용 됩니다. 그러나 모듈의 let 바인딩 함수의 경우 업캐스팅는 매개 변수 형식이 유연한 형식으로 선언 되지 않는 한 자동이 아닙니다. 자세한 내용은 [유연한 형식](flexible-Types.md)을 참조 하세요.

연산자 `:>` 는 정적 캐스트를 수행 합니다. 즉, 캐스트의 성공은 컴파일 시간에 결정 됩니다. 에서 사용 `:>` 하는 캐스팅이 성공적으로 컴파일되면 유효한 캐스트 이며 런타임에 오류가 발생 하지 않습니다.

`upcast` 연산자를 사용 하 여 이러한 변환을 수행할 수도 있습니다. 다음 식에서는 계층 구조를 변환 하는 방법을 지정 합니다.

```fsharp
upcast expression
```

업 캐스트 연산자를 사용 하는 경우 컴파일러는 컨텍스트에서 변환 하는 형식을 유추 하려고 합니다. 컴파일러가 대상 형식을 확인할 수 없는 경우 컴파일러에서 오류를 보고 합니다.

### <a name="downcasting"></a>다운 캐스팅

연산자 `:?>` 는 동적 캐스트를 수행 합니다. 즉, 캐스트의 성공은 런타임에 결정 됩니다. 연산자를 `:?>` 사용 하는 캐스트는 컴파일 시간에 검사 되지 않지만 런타임에는 지정 된 형식으로 캐스팅 하려고 시도 합니다. 개체가 대상 형식과 호환 되 면 캐스팅이 성공 합니다. 개체가 대상 형식과 호환 되지 않는 경우 런타임은을 발생 시킵니다 `InvalidCastException`.

`downcast` 연산자를 사용 하 여 동적 형식 변환을 수행할 수도 있습니다. 다음 식에서는 프로그램 컨텍스트에서 유추 되는 형식에 대 한 계층 구조를 아래로 변환 합니다.

```fsharp
downcast expression
```

`upcast` 연산자의 경우와 마찬가지로 컴파일러가 컨텍스트에서 특정 대상 형식을 유추할 수 없는 경우 오류를 보고 합니다.

다음 코드에서는 `:>` 및 `:?>` 연산자를 사용 하는 방법을 보여 줍니다. 이 코드는 변환이 실패할 `:?>` 경우 throw `InvalidCastException` 되기 때문에 변환이 성공 하는 것을 알고 있는 경우 연산자를 사용 하는 것을 보여 줍니다. 변환이 성공 하는 것이 확실 하지 않은 경우 `match` 식을 사용 하는 형식 테스트는 예외를 생성 하는 오버 헤드를 방지 하기 때문에 더 나은 방법입니다.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-2/snippet4403.fs)]

제네릭 연산자 `downcast` 및는 `upcast` 형식 유추를 사용 하 여 인수와 반환 형식을 결정 하기 때문에 위의 코드에서 다음을 바꿀 수 있습니다.

```fsharp
let base1 = d1 :> Base1
```

다음 문자열로 바꾸세요.

```fsharp
let base1 = upcast d1
```

이전 코드에서 인수 형식 및 반환 형식은 `Derived1` 각각 및 `Base1`입니다.

형식 테스트에 대 한 자세한 내용은 [일치 식](match-Expressions.md)을 참조 하세요.

## <a name="see-also"></a>참고자료

- [F# 언어 참조](index.md)
